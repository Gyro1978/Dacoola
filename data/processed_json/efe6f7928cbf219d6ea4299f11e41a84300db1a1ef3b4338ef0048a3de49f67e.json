{
    "id": "efe6f7928cbf219d6ea4299f11e41a84300db1a1ef3b4338ef0048a3de49f67e",
    "title": "Enterprise-grade natural language to SQL generation using LLMs: Balancing accuracy, latency, and scale",
    "link": "https://aws.amazon.com/blogs/machine-learning/enterprise-grade-natural-language-to-sql-generation-using-llms-balancing-accuracy-latency-and-scale/",
    "published_iso": "2025-04-24T16:23:48Z",
    "summary": "<p><em>This blog post is co-written with Renuka Kumar and Thomas Matthew from Cisco.</em></p> \n<p>Enterprise data by its very nature spans diverse data domains, such as security, finance, product, and HR. Data across these domains is often maintained across disparate data environments (such as <a href=\"https://aws.amazon.com/rds/aurora/\" rel=\"noopener\" target=\"_blank\">Amazon Aurora</a>, Oracle, and Teradata), with each managing hundreds or perhaps thousands of tables to represent and persist business data. These tables house complex domain-specific schemas, with instances of nested tables and multi-dimensional data that require complex database queries and domain-specific knowledge for data retrieval.</p> \n<p>Recent advances in generative AI have led to the rapid evolution of natural language to SQL (NL2SQL) technology, which uses pre-trained large language models (LLMs) and natural language to generate database queries in the moment. Although this technology promises simplicity and ease of use for data access, converting natural language queries to complex database queries with accuracy and at enterprise scale has remained a significant challenge. For enterprise data, a major difficulty stems from the common case of database tables having embedded structures that require specific knowledge or highly nuanced processing (for example, an embedded XML formatted string). As a result, NL2SQL solutions for enterprise data are often incomplete or inaccurate.</p> \n<p>This post describes a pattern that AWS and Cisco teams have developed and deployed that is viable at scale and addresses a broad set of challenging enterprise use cases. The methodology allows for the use of simpler, and therefore more cost-effective and lower latency, generative models by reducing the processing required for SQL generation.</p> \n<h2>Specific challenges for enterprise-scale NL2SQL</h2> \n<p>Generative accuracy is paramount for NL2SQL use cases; inaccurate SQL queries might result in a sensitive enterprise data leak, or lead to inaccurate results impacting critical business decisions. Enterprise-scale data presents specific challenges for NL2SQL, including the following:</p> \n<ul> \n <li><strong>Complex schemas optimized for storage (and not retrieval)</strong> – Enterprise databases are often distributed in nature and optimized for storage and not for retrieval. As a result, the table schemas are complex, involving nested tables and multi-dimensional data structures (for example, a cell containing an array of data). As a further result, creating queries for retrieval from these data stores requires specific expertise and involves complex filtering and joins.</li> \n <li><strong>Diverse and complex natural language queries</strong> – The user’s natural language input might also be complex because they might refer to a list of entities of interest or date ranges. Converting the logical meaning of these user queries into a database query can lead to overly long and complex SQL queries due to the original design of the data schema.</li> \n <li><strong>LLM knowledge gap </strong>– NL2SQL language models are typically trained on data schemas that are publicly available for education purposes and might not have the necessary knowledge complexity required of large, distributed databases in production environments. Consequently, when faced with complex enterprise table schemas or complex user queries, LLMs have difficulty generating correct query statements because they have difficulty understanding interrelationships between the values and entities of the schema.</li> \n <li><strong>LLM attention burden and latency </strong>– Queries containing multi-dimensional data often involve multi-level filtering over each cell of the data. To generate queries for cases such as these, the generative model requires more attention to support attending to the increase in relevant tables, columns, and values; analyzing the patterns; and generating more tokens. This increases the LLM’s query generation latency, and the likelihood of query generation errors, because of the LLM misunderstanding data relationships and generating incorrect filter statements.</li> \n <li><strong>Fine-tuning challenge</strong> – One common approach to achieve higher accuracy with query generation is to fine-tune the model with more SQL query samples. However, it is non-trivial to craft training data for generating SQL for embedded structures within columns (for example, JSON, or XML), to handle sets of identifiers, and so on, to get baseline performance (which is the problem we are trying to solve in the first place). This also introduces a slowdown in the development cycle.</li> \n</ul> \n<h2>Solution design and methodology</h2> \n<p>The solution described in this post provides a set of optimizations that solve the aforementioned challenges while reducing the amount of work that has to be performed by an LLM for generating accurate output. This work extends upon the post <a href=\"https://aws.amazon.com/blogs/machine-learning/generating-value-from-enterprise-data-best-practices-for-text2sql-and-generative-ai/\" rel=\"noopener\" target=\"_blank\">Generating value from enterprise data: Best practices for Text2SQL and generative AI</a>. That post has many useful recommendations for generating high-quality SQL, and the guidelines outlined might be sufficient for your needs, depending on the inherent complexity of the database schemas.</p> \n<p>To achieve generative accuracy for complex scenarios, the solution breaks down NL2SQL generation into a sequence of focused steps and sub-problems, narrowing the generative focus to the appropriate data domain. Using data abstractions for complex joins and data structure, this approach enables the use of smaller and more affordable LLMs for the task. This approach results in reduced prompt size and complexity for inference, reduced response latency, and improved accuracy, while enabling the use of off-the-shelf pre-trained models.</p> \n<h3>Narrowing scope to specific data domains</h3> \n<p>The solution workflow narrows down the overall schema space into the data domain targeted by the user’s query. Each data domain corresponds to the set of database data structures (tables, views, and so on) that are commonly used together to answer a set of related user queries, for an application or business domain. The solution uses the data domain to construct prompt inputs for the generative LLM.</p> \n<p>This pattern consists of the following elements:</p> \n<ul> \n <li><strong>Mapping input queries to domains </strong>– This involves mapping each user query to the data domain that is appropriate for generating the response for NL2SQL at runtime. This mapping is similar in nature to intent classification, and enables the construction of an LLM prompt that is scoped for each input query (described next).</li> \n <li><strong>Scoping data domain for focused prompt construction</strong> – This is a divide-and-conquer pattern. By focusing on the data domain of the input query, redundant information, such as schemas for other data domains in the enterprise data store, can be excluded. This might be considered as a form of prompt pruning; however, it offers more than prompt reduction alone. Reducing the prompt context to the in-focus data domain enables greater scope for few-shot learning examples, declaration of specific business rules, and more.</li> \n <li><strong>Augmenting SQL DDL definitions with metadata to enhance LLM inference</strong> – This involves enhancing the LLM prompt context by augmenting the SQL DDL for the data domain with descriptions of tables, columns, and rules to be used by the LLM as guidance on its generation. This is described in more detail later in this post.</li> \n <li><strong>Determine query dialect and connection information</strong> – For each data domain, the database server metadata (such as the SQL dialect and connection URI) is captured during use case onboarding and made available at runtime to be automatically included in the prompt for SQL generation and subsequent query execution. This enables scalability through decoupling the natural language query from the specific queried data source. Together, the SQL dialect and connectivity abstractions allow for the solution to be data source agnostic; data sources might be distributed within or across different clouds, or provided by different vendors. This modularity enables scalable addition of new data sources and data domains, because each is independent.</li> \n</ul> \n<h3>Managing identifiers for SQL generation (resource IDs)</h3> \n<p>Resolving identifiers involves extracting the named resources, as named entities, from the user’s query and mapping the values to unique IDs appropriate for the target data source prior to NL2SQL generation. This can be implemented using natural language processing (NLP) or LLMs to apply named entity recognition (NER) capabilities to drive the resolution process. This optional step has the most value when there are many named resources and the lookup process is complex. For instance, in a user query such as “In what games did Isabelle Werth, Nedo Nadi, and Allyson Felix compete?” there are named resources: ‘allyson felix’, ‘isabelle werth’, and ‘nedo nadi’. This step allows for rapid and precise feedback to the user when a resource can’t be resolved to an identifier (for example, due to ambiguity).</p> \n<p>This optional process of handling many or paired identifiers is included to offload the burden on LLMs for user queries with challenging sets of identifiers to be incorporated, such as those that might come in pairs (such as ID-type, ID-value), or where there are many identifiers. Rather than having the generative LLM insert each unique ID into the SQL directly, the identifiers are made available by defining a temporary data structure (such as a temporary table) and a set of corresponding insert statements. The LLM is prompted with few-shot learning examples to generate SQL for the user query by joining with the temporary data structure, rather than attempt identity injection. This results in a simpler and more consistent query pattern for cases when there are one, many, or pairs of identifiers.</p> \n<h3>Handling complex data structures: Abstracting domain data structures</h3> \n<p>This step is aimed at simplifying complex data structures into a form that can be understood by the language model without having to decipher complex inter-data relationships. Complex data structures might appear as nested tables or lists within a table column, for instance.</p> \n<p>We can define temporary data structures (such as views and tables) that abstract complex multi-table joins, nested structures, and more. These higher-level abstractions provide simplified data structures for query generation and execution. The top-level definitions of these abstractions are included as part of the prompt context for query generation, and the full definitions are provided to the SQL execution engine, along with the generated query. The resulting queries from this process can use simple set operations (such as IN, as opposed to complex joins) that LLMs are well trained on, thereby alleviating the need for nested joins and filters over complex data structures.</p> \n<h3>Augmenting data with data definitions for prompt construction</h3> \n<p>Several of the optimizations noted earlier require making some of the specifics of the data domain explicit. Fortunately, this only has to be done when schemas and use cases are onboarded or updated. The benefit is higher generative accuracy, reduced generative latency and cost, and the ability to support arbitrarily complex query requirements.</p> \n<p>To capture the semantics of a data domain, the following elements are defined:</p> \n<ul> \n <li>The standard tables and views in data schema, along with comments to describe the tables and columns.</li> \n <li>Join hints for the tables and views, such as when to use outer joins.</li> \n <li>Data domain-specific rules, such as which columns might not appear in a final select statement.</li> \n <li>The set of few-shot examples of user queries and corresponding SQL statements. A good set of examples would include a wide variety of user queries for that domain.</li> \n <li>Definitions of the data schemas for any temporary tables and views used in the solution.</li> \n <li>A domain-specific system prompt that specifies the role and expertise that the LLM has, the SQL dialect, and the scope of its operation.</li> \n <li>A domain-specific user prompt.</li> \n <li>Additionally, if temporary tables or views are used for the data domain, a SQL script is required that, when executed, creates the desired temporary data structures needs to be defined. Depending on the use case, this can be a static or dynamically generated script.</li> \n</ul> \n<p>Accordingly, the prompt for generating the SQL is dynamic and constructed based on the data domain of the input question, with a set of specific definitions of data structure and rules appropriate for the input query. We refer to this set of elements as the <em>data domain context</em>. The purpose of the data domain context is to provide the necessary prompt metadata for the generative LLM. Examples of this, and the methods described in the previous sections, are included in the <a href=\"https://github.com/aws-samples/blog-natural-language-data-retrieval\" rel=\"noopener\" target=\"_blank\">GitHub</a> repository. There is one context for each data domain, as illustrated in the following figure.</p> \n<p><a href=\"https://d2908q01vomqb2.cloudfront.net/f1f836cb4ea6efb2a0b1b99f41ad8b103eff4b59/2025/04/10/ML-18212-nl2sql-problem-scope-alt-res.png\" rel=\"noopener\" target=\"_blank\"><img alt=\"\" class=\"aligncenter wp-image-104299\" height=\"360\" src=\"https://d2908q01vomqb2.cloudfront.net/f1f836cb4ea6efb2a0b1b99f41ad8b103eff4b59/2025/04/10/ML-18212-nl2sql-problem-scope-alt-res-279x300.png\" width=\"334\" /></a></p> \n<h2>Bringing it all together: The execution flow</h2> \n<p>This section describes the execution flow of the solution. An example implementation of this pattern is available in the <a href=\"https://github.com/aws-samples/blog-natural-language-data-retrieval\" rel=\"noopener\" target=\"_blank\">GitHub</a> repository. Access the repository to follow along with the code.</p> \n<p>To illustrate the execution flow, we use an example database with data about Olympics statistics and another with the company’s employee vacation schedule. We follow the execution flow for the domain regarding Olympics statistics using the user query “In what games did Isabelle Werth, Nedo Nadi, and Allyson Felix compete?” to show the inputs and outputs of the steps in the execution flow, as illustrated in the following figure.</p> \n<p><a href=\"https://d2908q01vomqb2.cloudfront.net/f1f836cb4ea6efb2a0b1b99f41ad8b103eff4b59/2025/04/09/ML-18212-nl2sql-high-level-workflow.png\" rel=\"noopener\" target=\"_blank\"><img alt=\"High-level processing workflow\" class=\"aligncenter wp-image-104231 size-large\" height=\"472\" src=\"https://d2908q01vomqb2.cloudfront.net/f1f836cb4ea6efb2a0b1b99f41ad8b103eff4b59/2025/04/09/ML-18212-nl2sql-high-level-workflow-1024x472.png\" width=\"1024\" /></a></p> \n<h3>Preprocess the request</h3> \n<p>The first step of the NL2SQL flow is to preprocess the request. The main objective of this step is to classify the user query into a domain. As explained earlier, this narrows down the scope of the problem to the appropriate data domain for SQL generation. Additionally, this step identifies and extracts the referenced named resources in the user query. These are then used to call the identity service in the next step to get the database identifiers for these named resources<em>.</em></p> \n<p>Using the earlier mentioned example, the inputs and outputs of this step are as follows:</p> \n<div class=\"hide-language\"> \n <pre><code class=\"lang-code\">user_query = \"In what games did Isabelle Werth, Nedo Nadi and Allyson Felix compete?\"\npre_processed_request = request_pre_processor.run(user_query)\ndomain = pre_processed_request[app_consts.DOMAIN]\n\n# Output pre_processed_request:\n&nbsp; {'user_query': 'In what games did Isabelle Werth, Nedo Nadi and Allyson Felix compete?',\n&nbsp; &nbsp;'domain': 'olympics',\n&nbsp; &nbsp;'named_resources': {'allyson felix', 'isabelle werth', 'nedo nadi'} }</code></pre> \n</div> \n<h3>Resolve identifiers (to database IDs)</h3> \n<p>This step processes the named resources’ strings extracted in the previous step and resolves them to be identifiers that can be used in database queries. As mentioned earlier, the named resources (for example, “group22”, “user123”, and “I”) are looked up using solution-specific means, such through database lookups or an ID service.</p> \n<p>The following code shows the execution of this step in our running example:</p> \n<div class=\"hide-language\"> \n <pre><code class=\"lang-code\">named_resources = pre_processed_request[app_consts.NAMED_RESOURCES]\nif len(named_resources) &gt; 0:\n&nbsp; identifiers = id_service_facade.resolve(named_resources)\n&nbsp; # add identifiers to the pre_processed_request object\n&nbsp; pre_processed_request[app_consts.IDENTIFIERS] = identifiers\nelse:\n&nbsp; pre_processed_request[app_consts.IDENTIFIERS] = []\n\n# Output pre_processed_request:\n&nbsp; {'user_query': 'In what games did Isabelle Werth, Nedo Nadi and Allyson Felix compete?',\n&nbsp; &nbsp;'domain': 'olympics',\n&nbsp; &nbsp;'named_resources': {'allyson felix', 'isabelle werth', 'nedo nadi'},\n&nbsp; &nbsp;'identifiers': [ {'id': 34551, 'role': 32, 'name': 'allyson felix'},\n&nbsp; &nbsp;{'id': 129726, 'role': 32, 'name': 'isabelle werth'},\n&nbsp; &nbsp;{'id': 84026, 'role': 32, 'name': 'nedo nadi'} ] }</code></pre> \n</div> \n<h3>Prepare the request</h3> \n<p>This step is pivotal in this pattern. Having obtained the domain and the named resources along with their looked-up IDs, we use the corresponding context for that domain to generate the following:</p> \n<ul> \n <li>A prompt for the LLM to generate a SQL query corresponding to the user query</li> \n <li>A SQL script to create the domain-specific schema</li> \n</ul> \n<p>To create the prompt for the LLM, this step assembles the system prompt, the user prompt, and the received user query from the input, along with the domain-specific schema definition, including new temporary tables created as well as any join hints, and finally the few-shot examples for the domain. Other than the user query that is received as in input, other components are based on the values provided in the context for that domain.</p> \n<p>A SQL script for creating required domain-specific temporary structures (such as views and tables) is constructed from the information in the context. The domain-specific schema in the LLM prompt, join hints, and the few-shot examples are aligned with the schema that gets generated by running this script. In our example, this step is shown in the following code. The output is a dictionary with two keys, llm_prompt and sql_preamble. The value strings for these have been clipped here; the full output can be seen in the <a href=\"https://github.com/aws-samples/blog-natural-language-data-retrieval/blob/main/text_to_sql_notebook.ipynb\" rel=\"noopener\" target=\"_blank\">Jupyter notebook</a>.</p> \n<div class=\"hide-language\"> \n <pre><code class=\"lang-code\">prepared_request = request_preparer.run(pre_processed_request)\n\n# Output prepared_request:\n{'llm_prompt': 'You are a SQL expert. Given the following SQL tables definitions, ...\nCREATE TABLE games (id INTEGER PRIMARY KEY, games_year INTEGER, ...);\n...\n&lt;example&gt;\nquestion: How many gold medals has Yukio Endo won? answer: ```{\"sql\":\n\"SELECT a.id, count(m.medal_name) as \"count\"\nFROM athletes_in_focus a INNER JOIN games_competitor gc ...\nWHERE m.medal_name = 'Gold' GROUP BY a.id;\" }```\n&lt;/example&gt;\n...\n'sql_preamble': [ 'CREATE temp TABLE athletes_in_focus (row_id INTEGER\nPRIMARY KEY, id INTEGER, full_name TEXT DEFAULT NULL);',\n'INSERT INTO athletes_in_focus VALUES\n(1,84026,'nedo nadi'), (2,34551,'allyson felix'), (3,129726,'isabelle werth');\"]}</code></pre> \n</div> \n<h3>Generate SQL</h3> \n<p>Now that the prompt has been prepared along with any information necessary to provide the proper context to the LLM, we provide that information to the SQL-generating LLM in this step. The goal is to have the LLM output SQL with the correct join structure, filters, and columns. See the following code:</p> \n<div class=\"hide-language\"> \n <pre><code class=\"lang-code\">llm_response = llm_service_facade.invoke(prepared_request[ 'llm_prompt' ])\ngenerated_sql = llm_response[ 'llm_output' ]\n\n# Output generated_sql:\n{'sql': 'SELECT g.games_name, g.games_year FROM athletes_in_focus a\nJOIN games_competitor gc ON gc.person_id = a.id\nJOIN games g ON gc.games_id = g.id;'}</code></pre> \n</div> \n<h3>Execute the SQL</h3> \n<p>After the SQL query is generated by the LLM, we can send it off to the next step. At this step, the SQL preamble and the generated SQL are merged to create a complete SQL script for execution. The complete SQL script is then executed against the data store, a response is fetched, and then the response is passed back to the client or end-user. See the following code:</p> \n<div class=\"hide-language\"> \n <pre><code class=\"lang-code\">sql_script = prepared_request[ 'sql_preamble' ] + [ generated_sql[ 'sql' ] ]\ndatabase = app_consts.get_database_for_domain(domain)\nresults = rdbms_service_facade.execute_sql(database, sql_script)\n\n# Output results:\n{'rdbms_output': [\n('games_name', 'games_year'),\n('2004 Summer', 2004),\n...\n('2016 Summer', 2016)],\n'processing_status': 'success'}</code></pre> \n</div> \n<h2>Solution benefits</h2> \n<p>Overall, our tests have shown several benefits, such as:</p> \n<ul> \n <li><strong>High accuracy</strong> – This is measured by a string matching of the generated query with the target SQL query for each test case. In our tests, we observed over 95% accuracy for 100 queries, spanning three data domains.</li> \n <li><strong>High consistency</strong> – This is measured in terms of the same SQL generated being generated across multiple runs. We observed over 95% consistency for 100 queries, spanning three data domains. With the test configuration, the queries were accurate most of the time; a small number occasionally produced inconsistent results.</li> \n <li><strong>Low cost and latency </strong>– The approach supports the use of small, low-cost, low-latency LLMs. We observed SQL generation in the 1–3 second range using models Meta’s Code Llama 13B and Anthropic’s Claude Haiku 3.</li> \n <li><strong>Scalability </strong>– The methods that we employed in terms of data abstractions facilitate scaling independent of the number of entities or identifiers in the data for a given use case. For instance, in our tests consisting of a list of 200 different named resources per row of a table, and over 10,000 such rows, we measured a latency range of 2–5 seconds for SQL generation and 3.5–4.0 seconds for SQL execution.</li> \n <li><strong>Solving complexity</strong> – Using the data abstractions for simplifying complexity enabled the accurate generation of arbitrarily complex enterprise queries, which almost certainly would not be possible otherwise.</li> \n</ul> \n<p>We attribute the success of the solution with these excellent but lightweight models (compared to a Meta Llama 70B variant or Anthropic’s Claude Sonnet) to the points noted earlier, with the reduced LLM task complexity being the driving force. The implementation code demonstrates how this is achieved. Overall, by using the optimizations outlined in this post, natural language SQL generation for enterprise data is much more feasible than would be otherwise.</p> \n<h2>AWS solution architecture</h2> \n<p>In this section, we illustrate how you might implement the architecture on AWS. The end-user sends their natural language queries to the NL2SQL solution using a REST API. <a href=\"https://aws.amazon.com/api-gateway\" rel=\"noopener\" target=\"_blank\">Amazon API Gateway</a> is used to provision the REST API, which can be secured by <a href=\"https://aws.amazon.com/cognito/\" rel=\"noopener\" target=\"_blank\">Amazon Cognito</a>. The API is linked to an <a href=\"http://aws.amazon.com/lambda\" rel=\"noopener\" target=\"_blank\">AWS Lambda</a> function, which implements and orchestrates the processing steps described earlier using a programming language of the user’s choice (such as Python) in a serverless manner. In this example implementation, where <a href=\"https://aws.amazon.com/bedrock/\" rel=\"noopener\" target=\"_blank\">Amazon Bedrock</a> is noted, the solution uses Anthropic’s Claude Haiku 3.</p> \n<p>Briefly, the processing steps are as follows:</p> \n<ol> \n <li>Determine the domain by invoking an LLM on Amazon Bedrock for classification.</li> \n <li>Invoke Amazon Bedrock to extract relevant named resources from the request.</li> \n <li>After the named resources are determined, this step calls a service (the Identity Service) that returns identifier specifics relevant to the named resources for the task at hand. The Identity Service is logically a key/value lookup service, which might support for multiple domains.</li> \n <li>This step runs on Lambda to create the LLM prompt to generate the SQL, and to define temporary SQL structures that will be executed by the SQL engine along with the SQL generated by the LLM (in the next step).</li> \n <li>Given the prepared prompt, this step invokes an LLM running on Amazon Bedrock to generate the SQL statements that correspond to the input natural language query.</li> \n <li>This step executes the generated SQL query against the target database. In our example implementation, we used an SQLite database for illustration purposes, but you could use another database server.</li> \n</ol> \n<p>The final result is obtained by running the preceding pipeline on Lambda. When the workflow is complete, the result is provided as a response to the REST API request.</p> \n<p>The following diagram illustrates the solution architecture.</p> \n<p><a href=\"https://d2908q01vomqb2.cloudfront.net/f1f836cb4ea6efb2a0b1b99f41ad8b103eff4b59/2025/04/09/ML-18212-nl2sql-aws-impl-example.png\" rel=\"noopener\" target=\"_blank\"><img alt=\"Example solution architecture\" class=\"aligncenter wp-image-104232 size-large\" height=\"644\" src=\"https://d2908q01vomqb2.cloudfront.net/f1f836cb4ea6efb2a0b1b99f41ad8b103eff4b59/2025/04/09/ML-18212-nl2sql-aws-impl-example-1024x644.png\" width=\"1024\" /></a></p> \n<h2>Conclusion</h2> \n<p>In this post, the AWS and Cisco teams unveiled a new methodical approach that addresses the challenges of enterprise-grade SQL generation. The teams were able to reduce the complexity of the NL2SQL process while delivering higher accuracy and better overall performance.</p> \n<p>Though we’ve walked you through an example use case focused on answering questions about Olympic athletes, this versatile pattern can be seamlessly adapted to a wide range of business applications and use cases. The demo code is available in the <a href=\"https://github.com/aws-samples/blog-natural-language-data-retrieval\" rel=\"noopener\" target=\"_blank\">GitHub</a> repository. We invite you to leave any questions and feedback in the comments.</p> \n<hr /> \n<h3>About the authors</h3> \n<p style=\"clear: both;\"><a href=\"https://d2908q01vomqb2.cloudfront.net/f1f836cb4ea6efb2a0b1b99f41ad8b103eff4b59/2025/04/09/ML-18212-nl2sql-image-for-blog-bio-RK.jpg\" rel=\"noopener\" target=\"_blank\"><img alt=\"Author image\" class=\"alignleft wp-image-104266 size-full\" height=\"116\" src=\"https://d2908q01vomqb2.cloudfront.net/f1f836cb4ea6efb2a0b1b99f41ad8b103eff4b59/2025/04/09/ML-18212-nl2sql-image-for-blog-bio-RK.jpg\" width=\"100\" /></a></p> \n<p><strong>Renuka Kumar </strong>is a Senior Engineering Technical Lead at Cisco, where she has architected and led the development of Cisco’s Cloud Security BU’s AI/ML capabilities in the last 2 years, including launching first-to-market innovations in this space. She has over 20 years of experience in several cutting-edge domains, with over a decade in security and privacy. She holds a PhD from the University of Michigan in Computer Science and Engineering.</p> \n<p style=\"clear: both;\"><a href=\"https://d2908q01vomqb2.cloudfront.net/f1f836cb4ea6efb2a0b1b99f41ad8b103eff4b59/2025/04/09/ML-18212-nl2sql-image-for-blog-bio-TF.jpg\" rel=\"noopener\" target=\"_blank\"><img alt=\"Author image\" class=\"alignleft wp-image-104260 size-full\" height=\"133\" src=\"https://d2908q01vomqb2.cloudfront.net/f1f836cb4ea6efb2a0b1b99f41ad8b103eff4b59/2025/04/09/ML-18212-nl2sql-image-for-blog-bio-TF.jpg\" width=\"100\" /></a></p> \n<p><strong>Toby Fotherby</strong> is a Senior AI and ML Specialist Solutions Architect at AWS, helping customers use the latest advances in AI/ML and generative AI to scale their innovations. He has over a decade of cross-industry expertise leading strategic initiatives and master’s degrees in AI and Data Science. Toby also leads a program training the next generation of AI Solutions Architects.</p> \n<p style=\"clear: both;\"><a href=\"https://d2908q01vomqb2.cloudfront.net/f1f836cb4ea6efb2a0b1b99f41ad8b103eff4b59/2025/04/09/ML-18212-nl2sql-image-for-blog-bio-SK.png\" rel=\"noopener\" target=\"_blank\"><img alt=\"author image\" class=\"size-full wp-image-104265 alignleft\" height=\"138\" src=\"https://d2908q01vomqb2.cloudfront.net/f1f836cb4ea6efb2a0b1b99f41ad8b103eff4b59/2025/04/09/ML-18212-nl2sql-image-for-blog-bio-SK.png\" width=\"100\" /></a></p> \n<p><strong>Shweta Keshavanarayana</strong> is a Senior Customer Solutions Manager at AWS. She works with AWS Strategic Customers and helps them in their cloud migration and modernization journey. Shweta is passionate about solving complex customer challenges using creative solutions. She holds an undergraduate degree in Computer Science &amp; Engineering. Beyond her professional life, she volunteers as a team manager for her sons’ U9 cricket team, while also mentoring women in tech and serving the local community.</p> \n<p style=\"clear: both;\"><a href=\"https://d2908q01vomqb2.cloudfront.net/f1f836cb4ea6efb2a0b1b99f41ad8b103eff4b59/2025/04/09/ML-18212-nl2sql-image-for-blog-bio-TM.jpg\" rel=\"noopener\" target=\"_blank\"><img alt=\"author image\" class=\"alignleft size-full wp-image-104264\" height=\"117\" src=\"https://d2908q01vomqb2.cloudfront.net/f1f836cb4ea6efb2a0b1b99f41ad8b103eff4b59/2025/04/09/ML-18212-nl2sql-image-for-blog-bio-TM.jpg\" width=\"100\" /></a><strong>Thomas Matthew </strong>is an AL/ML Engineer at Cisco. Over the past decade, he has worked on applying methods from graph theory and time series analysis to solve detection and exfiltration problems found in Network security. He has presented his research and work at Blackhat and DevCon. Currently, he helps integrate generative AI technology into Cisco’s Cloud Security product offerings.</p> \n<p style=\"clear: both;\"><strong><img alt=\"\" class=\"alignleft size-thumbnail wp-image-104361\" height=\"144\" src=\"https://d2908q01vomqb2.cloudfront.net/f1f836cb4ea6efb2a0b1b99f41ad8b103eff4b59/2025/04/10/Daniel_Vaquero-100x144.png\" width=\"100\" />Daniel Vaquero </strong>is a Senior AI/ML Specialist Solutions Architect at AWS. He helps customers solve business challenges using artificial intelligence and machine learning, creating solutions ranging from traditional ML approaches to generative AI. Daniel has more than 12 years of industry experience working on computer vision, computational photography, machine learning, and data science, and he holds a PhD in Computer Science from UCSB.</p> \n<p style=\"clear: both;\"><a href=\"https://d2908q01vomqb2.cloudfront.net/f1f836cb4ea6efb2a0b1b99f41ad8b103eff4b59/2025/04/09/ML-18212-nl2sql-image-for-blog-bio-AV.png\" rel=\"noopener\" target=\"_blank\"><img alt=\"author image\" class=\"alignleft size-full wp-image-104262\" height=\"145\" src=\"https://d2908q01vomqb2.cloudfront.net/f1f836cb4ea6efb2a0b1b99f41ad8b103eff4b59/2025/04/09/ML-18212-nl2sql-image-for-blog-bio-AV.png\" width=\"100\" /></a><strong>Atul Varshneya </strong>is a former Principal AI/ML Specialist Solutions Architect with AWS. He currently focuses on developing solutions in the areas of AI/ML, particularly in generative AI. In his career of 4 decades, Atul has worked as the technology R&amp;D leader in multiple large companies and startups.</p> \n<p style=\"clear: both;\"><a href=\"https://d2908q01vomqb2.cloudfront.net/f1f836cb4ea6efb2a0b1b99f41ad8b103eff4b59/2025/04/09/ML-18212-nl2sql-image-for-blog-bio-JW.png\" rel=\"noopener\" target=\"_blank\"><img alt=\"author image\" class=\"alignleft size-full wp-image-104261\" height=\"140\" src=\"https://d2908q01vomqb2.cloudfront.net/f1f836cb4ea6efb2a0b1b99f41ad8b103eff4b59/2025/04/09/ML-18212-nl2sql-image-for-blog-bio-JW.png\" width=\"100\" /></a><strong>Jessica Wu</strong> is an Associate Solutions Architect at AWS. She helps customers build highly performant, resilient, fault-tolerant, cost-optimized, and sustainable architectures.</p>",
    "source_feed": "https://aws.amazon.com/blogs/machine-learning/feed/",
    "scraped_at_iso": "2025-05-02T21:32:12Z",
    "filter_verdict": {
        "importance_level": "Interesting",
        "topic": "AI Models",
        "reasoning_summary": "The article discusses the application of LLMs in enterprise-grade natural language to SQL generation, presenting verifiable advancements in NL2SQL technology with potential impact on data retrieval processes.",
        "primary_topic_keyword": "NL2SQL with LLMs"
    },
    "filter_error": null,
    "filtered_at_iso": "2025-05-02T21:32:41Z",
    "topic": "AI Models",
    "is_breaking": false,
    "primary_keyword": "NL2SQL with LLMs",
    "selected_image_url": "https://d2908q01vomqb2.cloudfront.net/f1f836cb4ea6efb2a0b1b99f41ad8b103eff4b59/2025/04/09/ML-18212-nl2sql-aws-impl-example-1002x630.png",
    "seo_agent_results": {
        "generated_title_tag": "NL2SQL with LLMs: Enterprise-Grade SQL Generation",
        "generated_meta_description": "Discover how AWS and Cisco optimized NL2SQL with LLMs for enterprise data, balancing accuracy, latency, and scalability.",
        "generated_json_ld": "<script type=\"application/ld+json\">  \n{  \n  \"@context\": \"https://schema.org\",  \n  \"@type\": \"NewsArticle\",  \n  \"headline\": \"NL2SQL with LLMs: Enterprise-Grade SQL Generation\",  \n  \"description\": \"Discover how AWS and Cisco optimized NL2SQL with LLMs for enterprise data, balancing accuracy, latency, and scalability.\",  \n  \"keywords\": [\"NL2SQL with LLMs\"],  \n  \"mainEntityOfPage\": { \"@type\": \"WebPage\", \"@id\": \"https://aws.amazon.com/blogs/machine-learning/enterprise-grade-natural-language-to-sql-generation-using-llms-balancing-accuracy-latency-and-scale/\" },  \n  \"image\": { \"@type\": \"ImageObject\", \"url\": \"https://d2908q01vomqb2.cloudfront.net/f1f836cb4ea6efb2a0b1b99f41ad8b103eff4b59/2025/04/09/ML-18212-nl2sql-aws-impl-example-1002x630.png\" },  \n  \"datePublished\": \"2025-04-24T16:23:48Z\",  \n  \"author\": { \"@type\": \"Person\", \"name\": \"AI News Team\" },  \n  \"publisher\": {  \n    \"@type\": \"Organization\",  \n    \"name\": \"Dacoola\",  \n    \"logo\": { \"@type\": \"ImageObject\", \"url\": \"https://i.imgur.com/A5Wdp6f.png\" }  \n  }  \n}  \n</script>",
        "generated_article_body_md": "## Enterprise-Grade Natural Language to SQL Generation Using LLMs  \n\nEnterprise data environments often span multiple domains—such as security, finance, and HR—with complex schemas stored across databases like Amazon Aurora, Oracle, and Teradata. Converting natural language queries into accurate SQL (NL2SQL with LLMs) has been challenging due to nested tables, multi-dimensional data, and domain-specific knowledge requirements. Recent advances in generative AI have improved NL2SQL capabilities, but enterprise-scale deployments still face hurdles in accuracy and latency.  \n\nAWS and Cisco developed a solution that simplifies SQL generation by breaking the process into focused steps, reducing the workload for LLMs. By narrowing queries to specific data domains, the method improves accuracy while allowing the use of smaller, cost-effective models like Meta’s Code Llama 13B and Anthropic’s Claude Haiku. The approach also introduces temporary data structures to abstract complex joins and nested schemas, making SQL generation more efficient.  \n\n### Key Benefits and Architecture  \n\nThe solution achieves over 95% accuracy and consistency while keeping SQL generation latency between 1-3 seconds. AWS’s architecture leverages Amazon Bedrock for LLM processing, Amazon API Gateway for REST endpoints, and AWS Lambda for serverless orchestration. This scalable approach ensures enterprise-grade performance without requiring fine-tuning for every schema variation."
    },
    "seo_agent_error": null,
    "generated_tags": [
        "Natural Language to SQL",
        "LLMs in Enterprise",
        "AWS SQL Generation",
        "NL2SQL with AI",
        "Enterprise Data Query",
        "Amazon Bedrock",
        "Code Llama 13B",
        "Claude Haiku",
        "SQL Generation Architecture",
        "AWS Lambda"
    ],
    "tags_agent_error": null,
    "trend_score": 10.0,
    "slug": "enterprise-grade-natural-language-to-sql-generation-using-llms-balancing-accurac",
    "audio_url": null
}