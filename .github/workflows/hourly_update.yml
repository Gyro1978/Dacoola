# .github/workflows/hourly_update.yml

name: Hourly News Update and Deploy

on:
  schedule:
    - cron: "0,20,40 * * * *" # Runs at 0, 20, and 40 minutes past the hour
  workflow_dispatch: # Allows manual triggering

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest
    concurrency:
      group: ${{ github.workflow }}-${{ github.ref }} # Ensures only one run per branch at a time
      cancel-in-progress: true
    permissions:
      contents: write # Required to push changes back to the repository

    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0 # Fetches all history

      - name: Set up Python 3.10
        uses: actions/setup-python@v5
        with:
          python-version: "3.10"
          cache: "pip" # Cache pip dependencies

      - name: Install Python Dependencies
        run: |
          python -m pip install --upgrade pip
          if [ -f requirements.txt ]; then
            pip install -r requirements.txt
          else
            echo "requirements.txt not found. Skipping pip install -r."
          fi

      - name: Setup Ollama
        id: setup_ollama
        run: |
          echo "Starting Ollama setup..."
          curl -fsSL https://ollama.com/install.sh | sh
          echo "Ollama installed."
          # Start Ollama in the background
          ollama serve &
          # Wait a few seconds for Ollama to start
          sleep 10
          echo "Ollama server started."
          # Pull initial models (add more as needed)
          # Check if pull was successful (ollama list might not show it immediately after pull if server is busy)
          echo "Pulling Mistral model..."
          if ollama pull mistral; then
            echo "Mistral pulled successfully."
          else
            echo "::error::Failed to pull Mistral. Check Ollama logs or network."
            # exit 1 # Optionally exit if a critical model fails
          fi
          echo "Pulling LLaVA model..."
          if ollama pull llava; then
            echo "LLaVA pulled successfully."
          else
            echo "::error::Failed to pull LLaVA. Check Ollama logs or network."
            # exit 1
          fi
          # Add other 'ollama pull <model_name>' commands here later
          # e.g., ollama pull llama3:70b
          # e.g., ollama pull bge-m3
          echo "Ollama model pulling complete (or attempted)."
          ollama list # List models to confirm

      - name: Run Main Script (Generates Content, Processes with Agents, etc.)
        env:
          # Pass ALL your .env variables as secrets or vars to the GHA context
          # Example for a few critical ones:
          DEEPSEEK_API_KEY: ${{ secrets.DEEPSEEK_API_KEY }} # Keep for now, might remove if fully Ollama
          SERPAPI_API_KEY: ${{ secrets.SERPAPI_API_KEY }}
          # Ollama will be accessed at http://localhost:11434 by Python scripts
          # General Website Config
          YOUR_WEBSITE_NAME: ${{ vars.YOUR_WEBSITE_NAME || 'Dacoola' }}
          YOUR_WEBSITE_LOGO_URL: ${{ vars.YOUR_WEBSITE_LOGO_URL || '' }}
          YOUR_SITE_BASE_URL: ${{ vars.YOUR_SITE_BASE_URL || '' }}
          MAX_HOME_PAGE_ARTICLES: ${{ vars.MAX_HOME_PAGE_ARTICLES || 20 }}
          # Twitter Credentials
          TWITTER_API_KEY: ${{ secrets.TWITTER_API_KEY }}
          TWITTER_API_SECRET: ${{ secrets.TWITTER_API_SECRET }}
          TWITTER_ACCESS_TOKEN: ${{ secrets.TWITTER_ACCESS_TOKEN }}
          TWITTER_ACCESS_TOKEN_SECRET: ${{ secrets.TWITTER_ACCESS_TOKEN_SECRET }}
          DAILY_TWEET_LIMIT: ${{ vars.DAILY_TWEET_LIMIT || 3 }}
          MAX_AGE_FOR_SOCIAL_POST_HOURS: ${{ vars.MAX_AGE_FOR_SOCIAL_POST_HOURS || 24 }}
          MAKE_INSTAGRAM_WEBHOOK_URL: ${{ secrets.MAKE_INSTAGRAM_WEBHOOK_URL }}
          # Google Ads (if still used, or for keyword ideas)
          GOOGLE_ADS_DEVELOPER_TOKEN: ${{ secrets.GOOGLE_ADS_DEV_TOKEN }}
          GOOGLE_ADS_LOGIN_CUSTOMER_ID: ${{ secrets.GOOGLE_ADS_LOGIN_CUSTOMER_ID }}
          GOOGLE_ADS_CLIENT_ID: ${{ secrets.GOOGLE_ADS_CLIENT_ID }}
          GOOGLE_ADS_CLIENT_SECRET: ${{ secrets.GOOGLE_ADS_CLIENT_SECRET }}
          GOOGLE_ADS_REFRESH_TOKEN: ${{ secrets.GOOGLE_ADS_REFRESH_TOKEN }}
          GOOGLE_ADS_CONFIGURATION_FILE_PATH: ${{ vars.GOOGLE_ADS_CONFIGURATION_FILE_PATH || './google-ads.yaml' }}
          SEARCH_CONSOLE_API_KEY: ${{ secrets.SEARCH_CONSOLE_API_KEY }}
          # Reddit API Credentials
          REDDIT_CLIENT_ID: ${{ secrets.REDDIT_CLIENT_ID }}
          REDDIT_CLIENT_SECRET: ${{ secrets.REDDIT_CLIENT_SECRET }}
          REDDIT_USERNAME: ${{ secrets.REDDIT_USERNAME }}
          REDDIT_PASSWORD: ${{ secrets.REDDIT_PASSWORD }}
          REDDIT_USER_AGENT: ${{ vars.REDDIT_USER_AGENT || 'DacoolaBot/0.1 by Dacoola' }}
          REDDIT_SUBREDDITS: ${{ vars.REDDIT_SUBREDDITS || 'testingground4bots' }}
          # Bluesky Credentials (repeat for 1, 2, 3)
          BLUESKY_HANDLE_1: ${{ secrets.BLUESKY_HANDLE_1 }}
          BLUESKY_APP_PASSWORD_1: ${{ secrets.BLUESKY_APP_PASSWORD_1 }}
          BLUESKY_HANDLE_2: ${{ secrets.BLUESKY_HANDLE_2 }}
          BLUESKY_APP_PASSWORD_2: ${{ secrets.BLUESKY_APP_PASSWORD_2 }}
          BLUESKY_HANDLE_3: ${{ secrets.BLUESKY_HANDLE_3 }}
          BLUESKY_APP_PASSWORD_3: ${{ secrets.BLUESKY_APP_PASSWORD_3 }}
        run: python src/main.py

      - name: Commit and Push Changes
        id: commit_push
        run: |
          git config --global user.name 'GitHub Actions Bot'
          git config --global user.email 'github-actions[bot]@users.noreply.github.com'

          # Add all generated/modified files
          # Using a more robust way to add all relevant files/dirs that main.py might touch
          git add public/sitemap.xml public/ads.txt public/articles/ public/all_articles.json \
                  data/processed_article_ids.txt data/twitter_daily_limit.json \
                  data/social_media_posts_history.json dacola.log gyro-picks.log \
                  data/processed_json/ \
                  data/scraped_articles/ \
                  public/latest.html public/search.html public/topic.html \
                  public/images/ # If images are saved here
                  || echo "Some files/dirs expected by 'git add' were not found or had no changes."

          if git diff --staged --quiet; then
            echo "No content changes detected by the script to commit."
            echo "changes_committed=false" >> $GITHUB_OUTPUT
          else
            echo "Content changes detected. Committing..."
            # Fetch latest changes from remote before committing locally
            git fetch origin ${{ github.ref_name }}
            # Try to rebase local commits on top of remote changes
            # This can help avoid merge commits if only this job modifies these files
            if git rebase origin/${{ github.ref_name }} --autostash; then
              echo "Rebase successful."
            else
              echo "Rebase failed. Aborting rebase and proceeding with merge strategy if needed later."
              git rebase --abort
              # As a fallback, ensure local working tree is clean if rebase failed mid-way
              # and we want to attempt a fresh commit based on what the script *just* generated.
              # This is complex; for now, let's assume the script's output is the desired state.
              # Re-add files as rebase might have changed staging area
              git add public/sitemap.xml public/ads.txt public/articles/ public/all_articles.json \
                  data/processed_article_ids.txt data/twitter_daily_limit.json \
                  data/social_media_posts_history.json dacola.log gyro-picks.log \
                  data/processed_json/ \
                  data/scraped_articles/ \
                  public/latest.html public/search.html public/topic.html \
                  public/images/ \
                  || echo "Re-add: Some files/dirs not found."
            fi
            
            git commit -m "Automated content update via GitHub Actions [skip ci]"
            echo "Changes committed."
            echo "changes_committed=true" >> $GITHUB_OUTPUT

            echo "Attempting to push changes..."
            retry_count=0; max_retries=5; delay_seconds=15;
            until git push origin ${{ github.ref_name }} || [ $retry_count -ge $max_retries ]; do
              retry_count=$((retry_count+1))
              echo "Push failed (Attempt ${retry_count}/${max_retries}). Pulling remote changes and retrying push."
              
              git fetch origin
              # Using merge with 'ours' strategy for conflicts in generated files like all_articles.json
              # This means if there's a conflict, our Action's version of the file wins.
              # This is suitable if the Action is the sole source of truth for these generated files.
              if ! git merge -X ours origin/${{ github.ref_name }} -m "Automated merge during push retry [skip ci]"; then
                 echo "::error::Merge also failed during push retry. Manual intervention likely needed for conflicts."
                 # Reset to avoid a broken state if merge fails badly
                 git reset --hard HEAD~1 # Go back before our commit
                 git reset --hard origin/${{ github.ref_name }} # Reset to remote
                 exit 1 # Exit to signal failure
              fi
              # Re-commit our changes after merge, as the merge might have created a merge commit
              # This is tricky. A simpler approach might be to force push if this is a dedicated branch.
              # For main branch, this merge strategy is safer.
              # If the merge was clean or 'ours' took precedence, our commit is still there.
              
              echo "Retrying push (${retry_count}/${max_retries})..."
              sleep $delay_seconds
            done

            if [ $retry_count -ge $max_retries ]; then
              echo "::error::Push failed after $max_retries attempts. Check repository for conflicts."
              exit 1
            fi
            echo "Changes pushed successfully."
          fi
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Check for Deployable Changes in public/
        id: check_public_changes
        run: |
          # Check if the 'public/' directory was actually changed in the last commit from this Action.
          # This is more reliable than just checking commit message.
          # We fetch origin again to ensure `origin/${{ github.ref_name }}` is up-to-date for comparison.
          git fetch origin ${{ github.ref_name }}
          if [[ "${{ steps.commit_push.outputs.changes_committed }}" == "true" ]]; then
            # Compare the public directory between the current HEAD and the previous state of the remote branch
            # This checks if *our commit that was just pushed* actually modified public/
            # Note: This assumes the push was successful and HEAD is now ahead of or same as remote.
            # A simpler check if HEAD is guaranteed to be the commit we just made: git diff --quiet HEAD^ HEAD -- public/
            if ! git diff --quiet origin/${{ github.ref_name }} HEAD -- public/; then
              echo "Deployable changes found in public/ directory by this Action run."
              echo "deploy_needed=true" >> $GITHUB_OUTPUT
            else
              echo "Commit made, but no net changes in public/ directory compared to remote. Skipping deploy."
              echo "deploy_needed=false" >> $GITHUB_OUTPUT
            fi
          else
             echo "No changes were committed by this script. Skipping deploy."
             echo "deploy_needed=false" >> $GITHUB_OUTPUT
          fi

      - name: Install Netlify CLI and Deploy
        if: steps.check_public_changes.outputs.deploy_needed == 'true'
        run: |
          echo "Deployable changes identified in public/. Proceeding with Netlify deployment."
          npm install -g netlify-cli
          netlify deploy --dir=public --prod --auth $NETLIFY_AUTH_TOKEN --site $NETLIFY_SITE_ID
        env:
          NETLIFY_AUTH_TOKEN: ${{ secrets.NETLIFY_AUTH_TOKEN }}
          NETLIFY_SITE_ID: ${{ secrets.NETLIFY_SITE_ID }}
